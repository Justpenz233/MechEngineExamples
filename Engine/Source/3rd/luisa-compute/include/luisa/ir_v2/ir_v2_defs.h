#pragma once
/// This file is generated by gen_ir_def.py
#include <type_traits>
#include <luisa/ir_v2/ir_v2_fwd.h>
#include <luisa/core/logging.h>
#include <luisa/ast/type.h>
#include <luisa/ast/type_registry.h>
namespace luisa::compute::ir_v2 {
struct LC_IR_API Func {
    luisa::unique_ptr<FuncData> _data;
    FuncTag _tag;
public:
    explicit Func(FuncTag tag) : _data(luisa::unique_ptr<FuncData>()), _tag(tag) {}
    explicit Func(FuncTag tag, luisa::unique_ptr<FuncData> data) : _data(std::move(data)), _tag(tag) {
        LUISA_ASSERT(tag == _data->tag(), "Mismatched tag!!!");
    }
    typedef FuncTag Tag;
    explicit Func(AssumeFn v);
    explicit Func(UnreachableFn v);
    explicit Func(AssertFn v);
    explicit Func(BindlessAtomicExchangeFn v);
    explicit Func(BindlessAtomicCompareExchangeFn v);
    explicit Func(BindlessAtomicFetchAddFn v);
    explicit Func(BindlessAtomicFetchSubFn v);
    explicit Func(BindlessAtomicFetchAndFn v);
    explicit Func(BindlessAtomicFetchOrFn v);
    explicit Func(BindlessAtomicFetchXorFn v);
    explicit Func(BindlessAtomicFetchMinFn v);
    explicit Func(BindlessAtomicFetchMaxFn v);
    explicit Func(CallableFn v);
    explicit Func(CpuExtFn v);
    [[nodiscard]] Tag tag() const noexcept {
        return _tag;
    }
    [[nodiscard]] bool isa(Tag tag) const noexcept {
        return this->tag() == tag;
    }
    template<class T>
        requires std::is_base_of_v<FuncData, T>
    [[nodiscard]] bool isa() const noexcept {
        return this->isa(T::static_tag());
    }
    template<class T>
        requires std::is_base_of_v<FuncData, T>
    [[nodiscard]] T *as() {
        return isa(T::static_tag()) ? static_cast<T *>(_data.get()) : nullptr;
    }
    template<class T>
        requires std::is_base_of_v<FuncData, T>
    [[nodiscard]] const T *as() const {
        return isa(T::static_tag()) ? static_cast<const T *>(_data.get()) : nullptr;
    }
    [[nodiscard]] const FuncMetadata &metadata() const noexcept;
    [[nodiscard]] bool has_side_effects() const noexcept { return metadata().has_side_effects; }
    Func() : Func(Tag::UNDEF) {}

    [[nodiscard]] FuncData *steal() noexcept {
        return _data.release();
    }
};
static_assert(sizeof(Func) == 16);
static_assert(sizeof(luisa::unique_ptr<FuncData>) == 8);
struct LC_IR_API AssumeFn : public FuncData {
public:
    typedef FuncTag Tag;
    [[nodiscard]] Tag tag() const noexcept override {
        return static_tag();
    }
    static constexpr Tag static_tag() noexcept {
        return Tag::ASSUME;
    }
public:
    luisa::string msg{};
    AssumeFn() = default;
    AssumeFn(luisa::string msg) : msg(std::move(msg)) {}
};
struct LC_IR_API UnreachableFn : public FuncData {
public:
    typedef FuncTag Tag;
    [[nodiscard]] Tag tag() const noexcept override {
        return static_tag();
    }
    static constexpr Tag static_tag() noexcept {
        return Tag::UNREACHABLE;
    }
public:
    luisa::string msg{};
    UnreachableFn() = default;
    UnreachableFn(luisa::string msg) : msg(std::move(msg)) {}
};
struct LC_IR_API AssertFn : public FuncData {
public:
    typedef FuncTag Tag;
    [[nodiscard]] Tag tag() const noexcept override {
        return static_tag();
    }
    static constexpr Tag static_tag() noexcept {
        return Tag::ASSERT;
    }
public:
    luisa::string msg{};
    AssertFn() = default;
    AssertFn(luisa::string msg) : msg(std::move(msg)) {}
};
struct LC_IR_API BindlessAtomicExchangeFn : public FuncData {
public:
    typedef FuncTag Tag;
    [[nodiscard]] Tag tag() const noexcept override {
        return static_tag();
    }
    static constexpr Tag static_tag() noexcept {
        return Tag::BINDLESS_ATOMIC_EXCHANGE;
    }
public:
    const Type *ty{};
    BindlessAtomicExchangeFn() = default;
    BindlessAtomicExchangeFn(const Type *ty) : ty(std::move(ty)) {}
};
struct LC_IR_API BindlessAtomicCompareExchangeFn : public FuncData {
public:
    typedef FuncTag Tag;
    [[nodiscard]] Tag tag() const noexcept override {
        return static_tag();
    }
    static constexpr Tag static_tag() noexcept {
        return Tag::BINDLESS_ATOMIC_COMPARE_EXCHANGE;
    }
public:
    const Type *ty{};
    BindlessAtomicCompareExchangeFn() = default;
    BindlessAtomicCompareExchangeFn(const Type *ty) : ty(std::move(ty)) {}
};
struct LC_IR_API BindlessAtomicFetchAddFn : public FuncData {
public:
    typedef FuncTag Tag;
    [[nodiscard]] Tag tag() const noexcept override {
        return static_tag();
    }
    static constexpr Tag static_tag() noexcept {
        return Tag::BINDLESS_ATOMIC_FETCH_ADD;
    }
public:
    const Type *ty{};
    BindlessAtomicFetchAddFn() = default;
    BindlessAtomicFetchAddFn(const Type *ty) : ty(std::move(ty)) {}
};
struct LC_IR_API BindlessAtomicFetchSubFn : public FuncData {
public:
    typedef FuncTag Tag;
    [[nodiscard]] Tag tag() const noexcept override {
        return static_tag();
    }
    static constexpr Tag static_tag() noexcept {
        return Tag::BINDLESS_ATOMIC_FETCH_SUB;
    }
public:
    const Type *ty{};
    BindlessAtomicFetchSubFn() = default;
    BindlessAtomicFetchSubFn(const Type *ty) : ty(std::move(ty)) {}
};
struct LC_IR_API BindlessAtomicFetchAndFn : public FuncData {
public:
    typedef FuncTag Tag;
    [[nodiscard]] Tag tag() const noexcept override {
        return static_tag();
    }
    static constexpr Tag static_tag() noexcept {
        return Tag::BINDLESS_ATOMIC_FETCH_AND;
    }
public:
    const Type *ty{};
    BindlessAtomicFetchAndFn() = default;
    BindlessAtomicFetchAndFn(const Type *ty) : ty(std::move(ty)) {}
};
struct LC_IR_API BindlessAtomicFetchOrFn : public FuncData {
public:
    typedef FuncTag Tag;
    [[nodiscard]] Tag tag() const noexcept override {
        return static_tag();
    }
    static constexpr Tag static_tag() noexcept {
        return Tag::BINDLESS_ATOMIC_FETCH_OR;
    }
public:
    const Type *ty{};
    BindlessAtomicFetchOrFn() = default;
    BindlessAtomicFetchOrFn(const Type *ty) : ty(std::move(ty)) {}
};
struct LC_IR_API BindlessAtomicFetchXorFn : public FuncData {
public:
    typedef FuncTag Tag;
    [[nodiscard]] Tag tag() const noexcept override {
        return static_tag();
    }
    static constexpr Tag static_tag() noexcept {
        return Tag::BINDLESS_ATOMIC_FETCH_XOR;
    }
public:
    const Type *ty{};
    BindlessAtomicFetchXorFn() = default;
    BindlessAtomicFetchXorFn(const Type *ty) : ty(std::move(ty)) {}
};
struct LC_IR_API BindlessAtomicFetchMinFn : public FuncData {
public:
    typedef FuncTag Tag;
    [[nodiscard]] Tag tag() const noexcept override {
        return static_tag();
    }
    static constexpr Tag static_tag() noexcept {
        return Tag::BINDLESS_ATOMIC_FETCH_MIN;
    }
public:
    const Type *ty{};
    BindlessAtomicFetchMinFn() = default;
    BindlessAtomicFetchMinFn(const Type *ty) : ty(std::move(ty)) {}
};
struct LC_IR_API BindlessAtomicFetchMaxFn : public FuncData {
public:
    typedef FuncTag Tag;
    [[nodiscard]] Tag tag() const noexcept override {
        return static_tag();
    }
    static constexpr Tag static_tag() noexcept {
        return Tag::BINDLESS_ATOMIC_FETCH_MAX;
    }
public:
    const Type *ty{};
    BindlessAtomicFetchMaxFn() = default;
    BindlessAtomicFetchMaxFn(const Type *ty) : ty(std::move(ty)) {}
};
struct LC_IR_API CallableFn : public FuncData {
public:
    typedef FuncTag Tag;
    [[nodiscard]] Tag tag() const noexcept override {
        return static_tag();
    }
    static constexpr Tag static_tag() noexcept {
        return Tag::CALLABLE;
    }
public:
    luisa::shared_ptr<CallableModule> module{};
    CallableFn() = default;
    CallableFn(luisa::shared_ptr<CallableModule> module) : module(std::move(module)) {}
};
struct LC_IR_API CpuExtFn : public FuncData {
public:
    typedef FuncTag Tag;
    [[nodiscard]] Tag tag() const noexcept override {
        return static_tag();
    }
    static constexpr Tag static_tag() noexcept {
        return Tag::CPU_EXT;
    }
public:
    luisa::shared_ptr<CpuExternFn> f{};
    CpuExtFn() = default;
    CpuExtFn(luisa::shared_ptr<CpuExternFn> f) : f(std::move(f)) {}
};
struct LC_IR_API Instruction {
    luisa::unique_ptr<InstructionData> _data;
    InstructionTag _tag;
public:
    explicit Instruction(InstructionTag tag) : _data(luisa::unique_ptr<InstructionData>()), _tag(tag) {}
    explicit Instruction(InstructionTag tag, luisa::unique_ptr<InstructionData> data) : _data(std::move(data)), _tag(tag) {
        LUISA_ASSERT(tag == _data->tag(), "Mismatched tag!!!");
    }
    typedef InstructionTag Tag;
    explicit Instruction(ArgumentInst v);
    explicit Instruction(ConstantInst v);
    explicit Instruction(CallInst v);
    explicit Instruction(PhiInst v);
    explicit Instruction(IfInst v);
    explicit Instruction(GenericLoopInst v);
    explicit Instruction(SwitchInst v);
    explicit Instruction(LocalInst v);
    explicit Instruction(ReturnInst v);
    explicit Instruction(PrintInst v);
    explicit Instruction(CommentInst v);
    explicit Instruction(UpdateInst v);
    explicit Instruction(RayQueryInst v);
    explicit Instruction(RevAutodiffInst v);
    explicit Instruction(FwdAutodiffInst v);
    [[nodiscard]] Tag tag() const noexcept {
        return _tag;
    }
    [[nodiscard]] bool isa(Tag tag) const noexcept {
        return this->tag() == tag;
    }
    template<class T>
        requires std::is_base_of_v<InstructionData, T>
    [[nodiscard]] bool isa() const noexcept {
        return this->isa(T::static_tag());
    }
    template<class T>
        requires std::is_base_of_v<InstructionData, T>
    [[nodiscard]] T *as() {
        return isa(T::static_tag()) ? static_cast<T *>(_data.get()) : nullptr;
    }
    template<class T>
        requires std::is_base_of_v<InstructionData, T>
    [[nodiscard]] const T *as() const {
        return isa(T::static_tag()) ? static_cast<const T *>(_data.get()) : nullptr;
    }

    [[nodiscard]] InstructionData *steal() noexcept {
        return _data.release();
    }
};
static_assert(sizeof(Instruction) == 16);
static_assert(sizeof(luisa::unique_ptr<InstructionData>) == 8);
struct LC_IR_API ArgumentInst : public InstructionData {
public:
    typedef InstructionTag Tag;
    [[nodiscard]] Tag tag() const noexcept override {
        return static_tag();
    }
    static constexpr Tag static_tag() noexcept {
        return Tag::ARGUMENT;
    }
public:
    bool by_value{};
    ArgumentInst() = default;
    ArgumentInst(bool by_value) : by_value(std::move(by_value)) {}
};
struct LC_IR_API ConstantInst : public InstructionData {
public:
    typedef InstructionTag Tag;
    [[nodiscard]] Tag tag() const noexcept override {
        return static_tag();
    }
    static constexpr Tag static_tag() noexcept {
        return Tag::CONSTANT;
    }
public:
    const Type *ty{};
    luisa::vector<uint8_t> value{};
    ConstantInst() = default;
    ConstantInst(const Type *ty, luisa::vector<uint8_t> value) : ty(std::move(ty)), value(std::move(value)) {}

    [[nodiscard]] uint16_t as_uint16() const noexcept {
        LUISA_ASSERT(ty->is_uint16(), "Type mismatch!");
        return *reinterpret_cast<const uint16_t *>(value.data());
    }
    [[nodiscard]] uint32_t as_uint32() const noexcept {
        LUISA_ASSERT(ty->is_uint32(), "Type mismatch!");
        return *reinterpret_cast<const uint32_t *>(value.data());
    }
    [[nodiscard]] uint64_t as_uint64() const noexcept {
        LUISA_ASSERT(ty->is_uint64(), "Type mismatch!");
        return *reinterpret_cast<const uint64_t *>(value.data());
    }
    [[nodiscard]] int16_t as_int16() const noexcept {
        LUISA_ASSERT(ty->is_int16(), "Type mismatch!");
        return *reinterpret_cast<const int16_t *>(value.data());
    }
    [[nodiscard]] int32_t as_int32() const noexcept {
        LUISA_ASSERT(ty->is_int32(), "Type mismatch!");
        return *reinterpret_cast<const int32_t *>(value.data());
    }
    [[nodiscard]] int64_t as_int64() const noexcept {
        LUISA_ASSERT(ty->is_int64(), "Type mismatch!");
        return *reinterpret_cast<const int64_t *>(value.data());
    }
    [[nodiscard]] half as_float16() const noexcept {
        LUISA_ASSERT(ty->is_float16(), "Type mismatch!");
        return *reinterpret_cast<const half *>(value.data());
    }
    [[nodiscard]] float as_float32() const noexcept {
        LUISA_ASSERT(ty->is_float32(), "Type mismatch!");
        return *reinterpret_cast<const float *>(value.data());
    }
    [[nodiscard]] bool as_bool() const noexcept {
        LUISA_ASSERT(ty->is_bool(), "Type mismatch!");
        return *reinterpret_cast<const bool *>(value.data());
    }
};
struct LC_IR_API CallInst : public InstructionData {
public:
    typedef InstructionTag Tag;
    [[nodiscard]] Tag tag() const noexcept override {
        return static_tag();
    }
    static constexpr Tag static_tag() noexcept {
        return Tag::CALL;
    }
public:
    Func func{};
    luisa::vector<Node *> args{};
    CallInst() = default;
    CallInst(Func func, luisa::vector<Node *> args) : func(std::move(func)), args(std::move(args)) {}
};
struct LC_IR_API PhiInst : public InstructionData {
public:
    typedef InstructionTag Tag;
    [[nodiscard]] Tag tag() const noexcept override {
        return static_tag();
    }
    static constexpr Tag static_tag() noexcept {
        return Tag::PHI;
    }
public:
    luisa::vector<PhiIncoming> incomings{};
    PhiInst() = default;
    PhiInst(luisa::vector<PhiIncoming> incomings) : incomings(std::move(incomings)) {}
};
struct LC_IR_API IfInst : public InstructionData {
public:
    typedef InstructionTag Tag;
    [[nodiscard]] Tag tag() const noexcept override {
        return static_tag();
    }
    static constexpr Tag static_tag() noexcept {
        return Tag::IF;
    }
public:
    Node *cond{};
    const BasicBlock *true_branch{};
    const BasicBlock *false_branch{};
    IfInst() = default;
    IfInst(Node *cond, const BasicBlock *true_branch, const BasicBlock *false_branch) : cond(std::move(cond)), true_branch(std::move(true_branch)), false_branch(std::move(false_branch)) {}
};
struct LC_IR_API GenericLoopInst : public InstructionData {
public:
    typedef InstructionTag Tag;
    [[nodiscard]] Tag tag() const noexcept override {
        return static_tag();
    }
    static constexpr Tag static_tag() noexcept {
        return Tag::GENERIC_LOOP;
    }
public:
    const BasicBlock *prepare{};
    Node *cond{};
    const BasicBlock *body{};
    const BasicBlock *update{};
    GenericLoopInst() = default;
    GenericLoopInst(const BasicBlock *prepare, Node *cond, const BasicBlock *body, const BasicBlock *update) : prepare(std::move(prepare)), cond(std::move(cond)), body(std::move(body)), update(std::move(update)) {}
};
struct LC_IR_API SwitchInst : public InstructionData {
public:
    typedef InstructionTag Tag;
    [[nodiscard]] Tag tag() const noexcept override {
        return static_tag();
    }
    static constexpr Tag static_tag() noexcept {
        return Tag::SWITCH;
    }
public:
    Node *value{};
    luisa::vector<SwitchCase> cases{};
    const BasicBlock *default_{};
    SwitchInst() = default;
    SwitchInst(Node *value, luisa::vector<SwitchCase> cases, const BasicBlock *default_) : value(std::move(value)), cases(std::move(cases)), default_(std::move(default_)) {}
};
struct LC_IR_API LocalInst : public InstructionData {
public:
    typedef InstructionTag Tag;
    [[nodiscard]] Tag tag() const noexcept override {
        return static_tag();
    }
    static constexpr Tag static_tag() noexcept {
        return Tag::LOCAL;
    }
public:
    Node *init{};
    LocalInst() = default;
    LocalInst(Node *init) : init(std::move(init)) {}
};
struct LC_IR_API ReturnInst : public InstructionData {
public:
    typedef InstructionTag Tag;
    [[nodiscard]] Tag tag() const noexcept override {
        return static_tag();
    }
    static constexpr Tag static_tag() noexcept {
        return Tag::RETURN;
    }
public:
    Node *value{};
    ReturnInst() = default;
    ReturnInst(Node *value) : value(std::move(value)) {}
};
struct LC_IR_API PrintInst : public InstructionData {
public:
    typedef InstructionTag Tag;
    [[nodiscard]] Tag tag() const noexcept override {
        return static_tag();
    }
    static constexpr Tag static_tag() noexcept {
        return Tag::PRINT;
    }
public:
    luisa::string fmt{};
    luisa::vector<Node *> args{};
    PrintInst() = default;
    PrintInst(luisa::string fmt, luisa::vector<Node *> args) : fmt(std::move(fmt)), args(std::move(args)) {}
};
struct LC_IR_API CommentInst : public InstructionData {
public:
    typedef InstructionTag Tag;
    [[nodiscard]] Tag tag() const noexcept override {
        return static_tag();
    }
    static constexpr Tag static_tag() noexcept {
        return Tag::COMMENT;
    }
public:
    luisa::string comment{};
    CommentInst() = default;
    CommentInst(luisa::string comment) : comment(std::move(comment)) {}
};
struct LC_IR_API UpdateInst : public InstructionData {
public:
    typedef InstructionTag Tag;
    [[nodiscard]] Tag tag() const noexcept override {
        return static_tag();
    }
    static constexpr Tag static_tag() noexcept {
        return Tag::UPDATE;
    }
public:
    Node *var{};
    Node *value{};
    UpdateInst() = default;
    UpdateInst(Node *var, Node *value) : var(std::move(var)), value(std::move(value)) {}
};
struct LC_IR_API RayQueryInst : public InstructionData {
public:
    typedef InstructionTag Tag;
    [[nodiscard]] Tag tag() const noexcept override {
        return static_tag();
    }
    static constexpr Tag static_tag() noexcept {
        return Tag::RAY_QUERY;
    }
public:
    Node *query{};
    const BasicBlock *on_triangle_hit{};
    const BasicBlock *on_procedural_hit{};
    RayQueryInst() = default;
    RayQueryInst(Node *query, const BasicBlock *on_triangle_hit, const BasicBlock *on_procedural_hit) : query(std::move(query)), on_triangle_hit(std::move(on_triangle_hit)), on_procedural_hit(std::move(on_procedural_hit)) {}
};
struct LC_IR_API RevAutodiffInst : public InstructionData {
public:
    typedef InstructionTag Tag;
    [[nodiscard]] Tag tag() const noexcept override {
        return static_tag();
    }
    static constexpr Tag static_tag() noexcept {
        return Tag::REV_AUTODIFF;
    }
public:
    const BasicBlock *body{};
    RevAutodiffInst() = default;
    RevAutodiffInst(const BasicBlock *body) : body(std::move(body)) {}
};
struct LC_IR_API FwdAutodiffInst : public InstructionData {
public:
    typedef InstructionTag Tag;
    [[nodiscard]] Tag tag() const noexcept override {
        return static_tag();
    }
    static constexpr Tag static_tag() noexcept {
        return Tag::FWD_AUTODIFF;
    }
public:
    const BasicBlock *body{};
    FwdAutodiffInst() = default;
    FwdAutodiffInst(const BasicBlock *body) : body(std::move(body)) {}
};
struct LC_IR_API Binding {
    luisa::unique_ptr<BindingData> _data;
    BindingTag _tag;
public:
    explicit Binding(BindingTag tag) : _data(luisa::unique_ptr<BindingData>()), _tag(tag) {}
    explicit Binding(BindingTag tag, luisa::unique_ptr<BindingData> data) : _data(std::move(data)), _tag(tag) {
        LUISA_ASSERT(tag == _data->tag(), "Mismatched tag!!!");
    }
    typedef BindingTag Tag;
    explicit Binding(BufferBinding v);
    explicit Binding(TextureBinding v);
    explicit Binding(BindlessArrayBinding v);
    explicit Binding(AccelBinding v);
    [[nodiscard]] Tag tag() const noexcept {
        return _tag;
    }
    [[nodiscard]] bool isa(Tag tag) const noexcept {
        return this->tag() == tag;
    }
    template<class T>
        requires std::is_base_of_v<BindingData, T>
    [[nodiscard]] bool isa() const noexcept {
        return this->isa(T::static_tag());
    }
    template<class T>
        requires std::is_base_of_v<BindingData, T>
    [[nodiscard]] T *as() {
        return isa(T::static_tag()) ? static_cast<T *>(_data.get()) : nullptr;
    }
    template<class T>
        requires std::is_base_of_v<BindingData, T>
    [[nodiscard]] const T *as() const {
        return isa(T::static_tag()) ? static_cast<const T *>(_data.get()) : nullptr;
    }

    [[nodiscard]] BindingData *steal() noexcept {
        return _data.release();
    }
};
static_assert(sizeof(Binding) == 16);
static_assert(sizeof(luisa::unique_ptr<BindingData>) == 8);
struct LC_IR_API BufferBinding : public BindingData {
public:
    typedef BindingTag Tag;
    [[nodiscard]] Tag tag() const noexcept override {
        return static_tag();
    }
    static constexpr Tag static_tag() noexcept {
        return Tag::BUFFER_BINDING;
    }
public:
    uint64_t handle{};
    uint64_t offset{};
    uint64_t size{};
    BufferBinding() = default;
    BufferBinding(uint64_t handle, uint64_t offset, uint64_t size) : handle(std::move(handle)), offset(std::move(offset)), size(std::move(size)) {}
};
struct LC_IR_API TextureBinding : public BindingData {
public:
    typedef BindingTag Tag;
    [[nodiscard]] Tag tag() const noexcept override {
        return static_tag();
    }
    static constexpr Tag static_tag() noexcept {
        return Tag::TEXTURE_BINDING;
    }
public:
    uint64_t handle{};
    uint64_t level{};
    TextureBinding() = default;
    TextureBinding(uint64_t handle, uint64_t level) : handle(std::move(handle)), level(std::move(level)) {}
};
struct LC_IR_API BindlessArrayBinding : public BindingData {
public:
    typedef BindingTag Tag;
    [[nodiscard]] Tag tag() const noexcept override {
        return static_tag();
    }
    static constexpr Tag static_tag() noexcept {
        return Tag::BINDLESS_ARRAY_BINDING;
    }
public:
    uint64_t handle{};
    BindlessArrayBinding() = default;
    BindlessArrayBinding(uint64_t handle) : handle(std::move(handle)) {}
};
struct LC_IR_API AccelBinding : public BindingData {
public:
    typedef BindingTag Tag;
    [[nodiscard]] Tag tag() const noexcept override {
        return static_tag();
    }
    static constexpr Tag static_tag() noexcept {
        return Tag::ACCEL_BINDING;
    }
public:
    uint64_t handle{};
    AccelBinding() = default;
    AccelBinding(uint64_t handle) : handle(std::move(handle)) {}
};
}// namespace luisa::compute::ir_v2
